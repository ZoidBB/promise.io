// Generated by CoffeeScript 1.11.1

/*
  eslint-disable
 */

(function() {
  var PromiseIO, PromiseSession, Q, uuid,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    slice = [].slice;

  Q = require('q');

  uuid = function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r, v;
      r = Math.random() * 16 | 0;
      v = c === 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  };

  PromiseSession = (function() {
    function PromiseSession(io, socket) {
      this.io = io;
      this.socket = socket;
      this.onReturn = bind(this.onReturn, this);
      this.returnValue = bind(this.returnValue, this);
      this.onNotify = bind(this.onNotify, this);
      this.onExecute = bind(this.onExecute, this);
      this.parseExports = bind(this.parseExports, this);
      this.onAcknowledgeExports = bind(this.onAcknowledgeExports, this);
      this.id = uuid();
      this.promises = {};
      this.socket.on('exports', this.parseExports);
      this.socket.on('acknowledge-exports', this.onAcknowledgeExports);
      this.socket.on('execute', this.onExecute);
      this.socket.on('return', this.onReturn);
      this.socket.on('notify', this.onNotify);
      this.locals = {};
      this.sendExports();
    }

    PromiseSession.prototype.sendExports = function() {
      var executionId;
      executionId = uuid();
      this.promises[executionId] = Q.defer();
      this.socket.emit('exports', executionId, this.io.constructExportsMessage());
      return this.promises[executionId].promise;
    };

    PromiseSession.prototype.onAcknowledgeExports = function(executionId) {
      return this.promises[executionId] && this.promises[executionId].resolve && this.promises[executionId].resolve();
    };

    PromiseSession.prototype.parseExports = function(executionId, exports) {
      var _, i, k, len, ref, v;
      ref = this.locals;
      for (k in ref) {
        v = ref[k];
        delete this.locals[k];
      }
      for (i = 0, len = exports.length; i < len; i++) {
        k = exports[i];
        _ = (function(_this) {
          return function(k) {
            var __;
            __ = function() {
              var _id, args;
              args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
              _id = uuid();
              _this.promises[_id] = Q.defer();
              _this.socket.emit('execute', _id, k, args);
              return _this.promises[_id].promise;
            };
            return __;
          };
        })(this);
        this.locals[k] = _(k);
      }
      this.socket.emit('acknowledge-exports', executionId);
      if (this.io.deferredReady != null) {
        return this.io.deferredReady.resolve(this.locals);
      }
    };

    PromiseSession.prototype.onExecute = function(executionId, name, args) {
      var ctx, e, error, v;
      ctx = function(session, executionId) {
        return {
          notify: (function(_this) {
            return function(value) {
              return session.notify(executionId, value);
            };
          })(this),
          remote: session.locals
        };
      };
      try {
        v = this.io.exports[name].apply(ctx(this, executionId), args);
      } catch (error1) {
        e = error1;
        error = {
          name: e.name,
          message: e.message,
          stack: e.stack,
          "arguments": e["arguments"]
        };
        this.returnValue(executionId, error, null);
        return;
      }
      if (typeof v.then === 'function') {
        return v.then((function(_this) {
          return function(v) {
            return _this.returnValue(executionId, null, v);
          };
        })(this))["catch"]((function(_this) {
          return function(e) {
            error = {
              name: e.name,
              message: e.message,
              stack: e.stack,
              "arguments": e["arguments"]
            };
            return _this.returnValue(executionId, error, null);
          };
        })(this)).progress((function(_this) {
          return function(v) {
            return _this.notify(executionId, v);
          };
        })(this)).done();
      } else {
        return this.returnValue(executionId, null, v);
      }
    };

    PromiseSession.prototype.notify = function(executionId, value) {
      return this.socket.emit('notify', executionId, value);
    };

    PromiseSession.prototype.onNotify = function(executionId, value) {
      var promise;
      promise = this.promises[executionId];
      return promise.notify(value);
    };

    PromiseSession.prototype.returnValue = function(executionId, err, value) {
      var error;
      if (value === this.socket) {
        value = null;
      }
      if (err != null) {
        error = new Error;
        error.message = err.message;
        error.name = err.name;
        error["arguments"] = err["arguments"];
        error.stack = err.stack;
      }
      return this.socket.emit('return', executionId, error, value);
    };

    PromiseSession.prototype.onReturn = function(executionId, err, value) {
      var promise;
      promise = this.promises[executionId];
      if (err != null) {
        return promise.reject(err);
      } else {
        return promise.resolve(value);
      }
    };

    return PromiseSession;

  })();

  PromiseIO = (function() {
    function PromiseIO(exports) {
      this.onConnect = bind(this.onConnect, this);
      this.exports = exports;
      this.clients = {};
    }

    PromiseIO.prototype.connect = function(url) {
      var SocketIO;
      SocketIO = require('socket.io-client');
      this.deferredReady = Q.defer();
      this.io = new SocketIO(url);
      this.io.on('connect', this.onConnect);
      return this.deferredReady.promise;
    };

    PromiseIO.prototype.listen = function(port) {
      var SocketIO;
      SocketIO = require('socket.io');
      this.io = new SocketIO(port);
      return this.io.on('connect', this.onConnect);
    };

    PromiseIO.prototype.constructExportsMessage = function() {
      if (this.exports != null) {
        return Object.keys(this.exports);
      }
      return [];
    };

    PromiseIO.prototype.onConnect = function(connection) {
      var session;
      if (connection == null) {
        connection = this.io;
      }
      session = new PromiseSession(this, connection);
      return this.clients[session.id] = session;
    };

    PromiseIO.prototype.sendExports = function() {
      var clientId, clientObj, funcs, ref;
      funcs = [];
      ref = this.clients;
      for (clientId in ref) {
        clientObj = ref[clientId];
        funcs.push(clientObj.sendExports());
      }
      return Q.all(funcs);
    };

    return PromiseIO;

  })();

  module.exports = PromiseIO;

}).call(this);
